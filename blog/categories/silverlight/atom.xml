<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: silverlight | valeriu caraulean]]></title>
  <link href="http://caraulean.com/blog/categories/silverlight/atom.xml" rel="self"/>
  <link href="http://caraulean.com/"/>
  <updated>2013-09-29T01:20:05+02:00</updated>
  <id>http://caraulean.com/</id>
  <author>
    <name><![CDATA[Valeriu Caraulean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Migrating from Silverlight to WPF, a case study]]></title>
    <link href="http://caraulean.com/blog/2012/07/19/migrating-from-silverlight-to-wpf-a-case-study/"/>
    <updated>2012-07-19T19:06:48+02:00</updated>
    <id>http://caraulean.com/blog/2012/07/19/migrating-from-silverlight-to-wpf-a-case-study</id>
    <content type="html"><![CDATA[<h4>A case study on porting an application that uses <a href="http://caliburnmicro.codeplex.com/">Caliburn.Micro</a> and <a href="http://www.telerik.com/">Telerik’s visual components</a> from Silverlight to WPF</h4>

<p>I wrote that <a href="/blog/2012/07/18/fearing-about-silverlights-future-dont/">nobody should fear an eventual migration from Silverlight to WPF</a>. But I wanted as well to work on a “proof of concept” and try to find what difficulties may arise in a such migration and how easy is to actually do it. And, preferable, do it in a small project before taking on big targets.</p>

<p>I’ll use <a href="https://github.com/vcaraulean/Caliburn.Micro.Telerik">Caliburn.Micro.Telerik</a> as my test ground. It’s a library aimed to <a href="/blog/2011/06/05/integration-of-caliburn-micro-and-teleriks-silverlight-controls/">integrate Caliburn.Micro and Telerik’s component suite for Silverlight</a>. And as I’ve been getting requests to port conventions and few helpers to WPF I’ll use it as my playground.</p>

<p>Silverlight solution contains a Silverlight library and two Silverlight applications to test conventions and other stuff. Both applications together contains more than 10 views with corresponding view models, so it should provide a fairly relevant impression about how easy is to migrate from Silverlight to WPF.</p>

<h3>Step 1</h3>

<p>Restructure solution to allow cohabitation of two different versions. In this case, I want to keep both versions, so I’ll be copying files from one project to another. Duplication, but at this moment I don’t want the overhead of keeping two target frameworks with a common codebase.</p>

<h3>Step 2</h3>

<p>Creating the destination point – a .NET library or WPF application:</p>

<ul>
<li>Create new Class Library targeting .NET 4 framework or WPF Application with .NET 4 Client profile.</li>
<li>Add Caliburn.Micro using Nuget</li>
<li>If it’s a class library, add references to WPF’s assemblies: PresentationCore, PresentationFramework, System.Xaml &amp; WindowsBase</li>
<li>Add references to Telerik’s assemblies. I’ve picked ones with same names as in corresponding Silverlight project.</li>
</ul>


<h3>Step 3</h3>

<p>Getting the application canvas and infrastructure code right. This includes Caliburn’s bootstrapper, the main view &amp; all stuff to get application running. There is one difference, the main view in WPF should be a Window, while in Silverlight it was a simple UserControl.</p>

<h3>Step 4</h3>

<p>Migrating your views &amp; view models. In the case of Caliburn.Micro.Telerik examples project I’ve had to just copy the files from Silverlight to WPF project. Then it compiled and run just fine.</p>

<h3>Step 5</h3>

<p>Cleanup.</p>

<h3>Conclusions</h3>

<p>Telerik have done a pretty good job on keeping their Silverlight and WPF components in a very similar shape and at a very high compatibility level between both platforms. I hope that it doesn’t diminishes any of advantages/facilities/features of either platform.</p>

<p>Migrating a Caliburn.Micro application from SL to WPF is a piece of cake. Despite few minor differences in infrastructure code between WPF &amp; Silverlight versions of WPF, you’re pretty much left with move files, cleanup namespaces and Run. View models are ported without any issues, however you may encounter few with the views.</p>

<p>As this was a small project, porting is very straightforward and relatively simple. In a real application with lots of stuff and moving pieces you will have some more work to do. Particularly when you have some Silverlight specific code or where you’re working around platform’s limitations. Take for example mouse events. To get a “double click” you have to write custom code. Middle click doesn’t exist in Silverlight. Printing is different, file system interactions too. Communication layer (WCF &amp; service references) will need a review. There’s are no RIA services in WPF (I may be wrong here). The list may go on further, but I’ll stop here. I hope to have much more info to share about migration process as I’ll probably will take part in moving a much larger application from Silverlight to WPF.</p>

<p>That’s all. I hope my experience will help someone else to go over the fear and burden of porting a Silverlight application to WPF.</p>

<p>PS: you can have a look at final result, get sources and compare both versions on <a href="http://github.com/vcaraulean/Caliburn.Micro.Telerik">GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fearing about Silverlight's future? Don't...]]></title>
    <link href="http://caraulean.com/blog/2012/07/18/fearing-about-silverlights-future-dont/"/>
    <updated>2012-07-18T13:26:29+02:00</updated>
    <id>http://caraulean.com/blog/2012/07/18/fearing-about-silverlights-future-dont</id>
    <content type="html"><![CDATA[<p>Just accept the facts, prepare &amp; migrate to WPF when ready.</p>

<p>When you have something worrying you, the best way to tackle it is to cut it straight and act on it. That's the way to get it out of your head. If not, you're left on the mercy of external factors that may change the circumstances and the problem will go away.</p>

<blockquote><p>“If you wait by the river long enough, the bodies of your enemies will float by.”
- Sun Tzu</p></blockquote>

<p>For some time I have a strange feeling about Silverlight. Few years ago it was "the solution" for cross-platform Rich Internet Applications. It was Microsoft's "offre du jour" for Enterprise Software development, offering ease of deployment &amp; update, run anywhere premise and offering a (part of) common development platform for Windows: XAML &amp; .NET.</p>

<h4>Times are changing</h4>

<p>The rapid rise of HTML5 &amp; CSS3 have had a huge impact on client side application development. Reach features of "next web" markup &amp; styling together with explosion of JavaScript popularity (adoption &amp; tooling) makes Web Applications an extremely viable "Rich Client" solution even for Enterprise Software. And sometimes it works nicely for mobile applications too.</p>

<p>Then there is Microsoft's focus on Windows 8 &amp; WinRT. All bets are on the new and shiny Windows 8, Office 2013, Windows Phone 8 &amp; Surface. WinRT is "the new Silverlight", this time without the goal to run on multiple platforms but with a lot of aspirations to support Microsoft's moves in tablet and mobile markets.</p>

<h4>And now</h4>

<p>Looking back at my experience as a Silverlight developer, there is a sensible level of deception and frustration. Missing features, cut-off or half-backed functionality, leaking resources and a failed promise to offer a viable way to develop cross-platform applications. And the worst of all, I think we've lost time working around various limitations of Silverlight in order to get it working properly and comply with our requirements (somewhere between 10 to 15 %%).</p>

<p>The current version of Silverlight is 5. Microsoft is quiet about his future - current releases will be supported, but absolute no information about next versions. Instead, there are plenty of rumors that there will be no Silverlight 6. Microsoft is too busy pushing the Windows 8 and the Silverlight's incarnation on this platform, the WinRT.</p>

<h4>What do you have to loose? Not too much...</h4>

<p>More important is what you can gain by migrating your current Silverlight application to WPF:</p>

<ul>
<li>A normal Windows application, running on all versions of Windows from XP to 8.</li>
<li>The power of WPF &amp; full .NET framework.</li>
<li>Full integration with OS: printing, scanning, file system, services.</li>
<li>Better integration with other applications. MS Office, Reporting tools, you name it.</li>
<li>Touch &amp; Multi-Touch support. You can create applications for Windows 8 that aren't Metro, but are touch friendly.</li>
</ul>


<p>The main thing you’d probably miss is the ability to run application directly in your browser, without installing it. But if it’s an Silverlight OOB application, you probably need some features not available in his sandboxed environment and running in browser is already out of question.</p>

<h4>Would it be hard to migrate to WPF? It depends...</h4>

<p>If you have a well structured application that follows good practices, it shouldn’t be a hard task to complete. Major steps to migrate a Silverlight application to WPF will be:</p>

<ul>
<li><strong>Libraries &amp; frameworks</strong>. If you were careful picking those, it now should be a pretty simple task of switching assemblies. Should it be the MVVM framework (Caliburn.Micro or MVVMLight), IoC container (Castle.Windsor) or third-party visual component library (Telerik, DevExpress) - usually they have versions for Silverlight and WPF. In ideal case you will end up just swapping assemblies.</li>
<li><strong>Porting the source code</strong>. Again, depending on how you've approached development process it may be not so hard to do. It most cases it will be just "copy files" over. But some parts would need to be rewritten, often to simplify or throw away things. I estimate that volume of code to be reviewed/rewritten will be around 15% of overall client side code. Resharper &amp; good old Find-Replace are your friends here.</li>
<li><strong>Installer &amp; application updates</strong>. Up until now you relied on Silverlight to install &amp; update the application. This part should be redone. ClickOnce is a viable solution, it will serve well your initial requirements to install and update the application. It would take 2-3 days to build, test &amp; make available a decent solution for this problem.</li>
<li><strong>Rigorous testing after migration</strong>. May be most difficult and time consuming one if you have a large application as there is no tooling support to help with it.</li>
</ul>


<p>I'm not advocating blindly for immediate migration of every Silverlight application to WPF. If your application have reached his first release, doesn't have a long lifespan and current users are happy - you'll probably be fine sticking with Silverlight. But if you're still in active development or the application is a part of company's strategic products &amp; directions, you should very seriously consider the move.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using WP7's ProgressIndicator with Caliburn.Micro]]></title>
    <link href="http://caraulean.com/blog/2011/12/09/using-wp7s-progressindicator-with-caliburn-micro/"/>
    <updated>2011-12-09T01:45:10+01:00</updated>
    <id>http://caraulean.com/blog/2011/12/09/using-wp7s-progressindicator-with-caliburn-micro</id>
    <content type="html"><![CDATA[<p>The Windows Phone SDK 7.1 introduced a new control to show the progress of long operations or interactions, ProgressIndicator. As I love much the <a href="http://caliburnmicro.codeplex.com">Caliburn.Micro</a> framework I got some time to integrate neatly ProgressIndicator with the rest of application and services using Caliburn’s container.</p>

<p>First of all, let’s define our application facing progress service:</p>

<pre><code>public interface IProgressService {
    void Show();
    void Show(string text);
    void Hide();
}
</code></pre>

<p>Pretty simple, yes...</p>

<p>The implementation was partly inspired by <a href="http://www.jeff.wilcox.name/2011/07/creating-a-global-progressindicator-experience-using-the-windows-phone-7-1-sdk-beta-2/">Jeff Wilcox’s article about creating a global ProgressIndicator</a>.</p>

<p>It’s pretty simple and straightforward: we’re getting the Root Application Frame and hooking up to the Navigated event. His arguments contain the page being navigated to. Then we’re attaching our instance of ProgressIndicator to that page. And the service uses Show/Hide methods to manipulate the state of indicator. The code:</p>

<pre><code>public class ProgressService : IProgressService {
    const string DefaultIndicatorText = "Loading...";
    private readonly ProgressIndicator progressIndicator;

    public ProgressService(PhoneApplicationFrame rootFrame)
    {
        progressIndicator = new ProgressIndicator {Text = DefaultIndicatorText};

        rootFrame.Navigated += RootFrameOnNavigated;
    }

    private void RootFrameOnNavigated(object sender, NavigationEventArgs args)
    {
        var content = args.Content;
        var page = content as PhoneApplicationPage;
        if (page == null)
            return;

        page.SetValue(SystemTray.ProgressIndicatorProperty, progressIndicator);
    }

    public void Show()
    {
        Show(DefaultIndicatorText);
    }

    public void Show(string text)
    {
        progressIndicator.Text = text;
        progressIndicator.IsIndeterminate = true;
        progressIndicator.IsVisible = true;
    }

    public void Hide()
    {
        progressIndicator.IsIndeterminate = false;
        progressIndicator.IsVisible = false;
    }
}
</code></pre>

<p>The last piece of this mini-puzzle is wiring up the service to container and made it available to the rest of application:</p>

<pre><code>public class AppBootstrapper : PhoneBootstrapper {
    private PhoneContainer container;

    protected override void Configure()
    {
        container = new PhoneContainer(RootFrame);
        container.Instance&lt;IProgressService&gt;(new ProgressService(RootFrame));
</code></pre>

<p>That’s all. Now declare a dependency on IProgressService whenever you need it and show/hide to give a nice feedback to the User when your application is doing something long. You never forget that User is the ultimate chief and judge in our business, right?..</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Life After Silverlight 5]]></title>
    <link href="http://caraulean.com/blog/2011/11/15/the-life-after-silverlight-5/"/>
    <updated>2011-11-15T13:28:07+01:00</updated>
    <id>http://caraulean.com/blog/2011/11/15/the-life-after-silverlight-5</id>
    <content type="html"><![CDATA[<p>There is a lot of panic in Microsoft eco-system caused by some <a href="http://www.zdnet.com/blog/microsoft/will-there-be-a-silverlight-6-and-does-it-matter/11180">rumors that Silverlight 5 will be the last of the family</a>. Developers are crying about skills being buried and managers fearing about the future of in-house enterprise apps.</p>

<p>And everyone is guessing what will be Microsoft pushing in the segment currently occupied by Silverlight. Now we have two available options, the new guy in the block - the HTML 5, and the good old and trusty WPF. Won’t mention Windows 8 here as it’s way to the Enterprise is too long to be considered as an option.</p>

<p>So, everyone is watching the next move of Microsoft as there is not a clear winner – HTML 5 is too young to be considered seriously and WPF is too old to be considered as a long-time investment. When Silverlight was a competitor <a href="http://www.scottlogic.co.uk/blog/colin/2011/05/flex-silverlight-html5-time-to-decide/">the choice was rather easy</a>, now <a href="http://www.scottlogic.co.uk/blog/colin/2011/11/the-untimely-demise-of-the-plugin-and-how-lob-developments-will-suffer/">picture is much more blurred</a>.</p>

<h2>In my view</h2>

<p>XAML &amp; .NET will stay with us. Will it be WPF, Metro or anything MS will roll out for Desktop and LOB applications it will be based on those two pillars. At least for 7-10 years we’re assured.</p>

<p>I’ll make few guesses, what MS’s steps will be after Silverlight end will be announced (it will be interesting to read it in a year or two):</p>

<ul>
<li>A promise that Silverlight 5 will be supported for next 3-4 years</li>
<li>Actively encouraging developers to migrate Silverlight apps to WPF</li>
<li>Newer versions of WPF will promote features previously hyped as Silverlight’s exclusives (in-browser apps, sandboxing, web deployment &amp; updates and others) minus the ability to run in browsers on various platforms.</li>
</ul>


<p>As for companies struggling with the choice right now (and it will probably true for near future), you’ll have to decide:</p>

<ul>
<li>Interaction and Data intensive applications, Rich User Experience, Resource Intensive application, deep OS integration – embrace the WPF and be happy (if you don’t mind to lock yourself to MS and Windows).</li>
<li>Platform independent, high user base, moderately interactive UIs, presentation and manipulation of small amounts of data – your best bet is the Web: HTML5, CSS3 and JavaScript will be your tools.</li>
</ul>


<p>And if you still struggle with the choice the best thing you can do next is to look at your current development team. If they are more experienced and efficient with Web technologies you’re set. If they are mostly Desktop specialists then you’d want to explore their productivity to the max and get the release date closer. You’re sorted.</p>

<p><strong>And the last word</strong>: don’t be a mono-disciplinary developer. Don’t lock yourself exclusively in Desktop or Web, Microsoft or LAMP or whatever. The day you’ll fail to pick, learn and use efficiently a new tool/framework will mean your career as a Professional Software Developer is done. Be open. Look around, there are so many amazing things in Software Development industry. Just pick something new and learn. It will be one of the best investments you can do in your future. You can do it right now...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to make Caliburn.Micro and Silverlight resources in MergedDictionaries play nicely together]]></title>
    <link href="http://caraulean.com/blog/2011/09/13/how-to-make-caliburn-micro-and-silverlight-resources-in-mergeddictionaries-play-nicely-together/"/>
    <updated>2011-09-13T23:43:00+02:00</updated>
    <id>http://caraulean.com/blog/2011/09/13/how-to-make-caliburn-micro-and-silverlight-resources-in-mergeddictionaries-play-nicely-together</id>
    <content type="html"><![CDATA[<p>I’ve fixed an error in our codebase that prevented Caliburn’s bootstrapper and application resources to live happily together. That was manifesting like warnings in xaml about missing resources and styles, no right styles in Visual Studio designer and so on.</p>

<p>Now, to reproduce the problem we have to follow Caliburn’s guidelines then make few changes:</p>

<ul>
<li>Create new Silverlight 4 application</li>
<li>Add Caliburn.Micro NuGet package</li>
<li><a href="http://caliburnmicro.codeplex.com/wikipage?title=Nuget">Configure your application</a> to bootstrap Caliburn</li>
<li>Add new Resource Dictionary to host your common styles/brushes/whatever</li>
<li>Include your dictionary in MergedDictionaries section</li>
<li>Add a fancy color brush and use it in ShellView.xaml by referencing it as a static resource</li>
<li>Build your app</li>
</ul>


<p>Your application will compile and run fine. However, you can spot few <strong>issues</strong> with your code:</p>

<ul>
<li>ShellView.xaml:

<ul>
<li>Xaml editor displaying warning: “The resource could not be resolved”</li>
<li>VS Designer will not use your resource on design surface</li>
</ul>
</li>
<li>App.xaml

<ul>
<li>Xaml editor displaying warning: “The designer does not support loading dictionaries that mix 'ResourceDictionary' items without a key and other items in the same collection. Please ensure that the 'Resources' property does not contain 'ResourceDictionary' items without a key, or that the 'ResourceDictionary' item is the only element in the collection.”</li>
</ul>
</li>
</ul>


<p>To solve this problem you have to modify your App.xaml.</p>

<p>The original App.xaml fragment, as by following recommendations:</p>

<pre><code>&lt;Application.Resources&gt;
    &lt;ResourceDictionary&gt;
        &lt;ResourceDictionary.MergedDictionaries&gt;
            &lt;ResourceDictionary Source="Themes/Generic.xaml" /&gt;
        &lt;/ResourceDictionary.MergedDictionaries&gt;
    &lt;/ResourceDictionary&gt;
    &lt;local:AppBootstrapper x:Key="bootstrapper" /&gt;
&lt;/Application.Resources&gt;
</code></pre>

<p>Now, the <strong>corrected version</strong> that removes all issues I’ve described earlier:</p>

<pre><code>&lt;Application.Resources&gt;
    &lt;ResourceDictionary&gt;
        &lt;ResourceDictionary.MergedDictionaries&gt;
            &lt;ResourceDictionary Source="Themes/Generic.xaml" /&gt;
            &lt;ResourceDictionary&gt;
                &lt;local:AppBootstrapper x:Key="bootstrapper" /&gt;
            &lt;/ResourceDictionary&gt;
        &lt;/ResourceDictionary.MergedDictionaries&gt;
    &lt;/ResourceDictionary&gt;
&lt;/Application.Resources&gt;
</code></pre>

<p>Actually, this fragment is the <strong>recommended way of instantiating boostrapper for WPF</strong> version of Caliburn.Micro. Why it isn’t recommended also for Silverlight? I don’t know. For our rather large project I haven’t seen any downgrades and issues using this approach. Just few annoying bugs were gone...</p>
]]></content>
  </entry>
  
</feed>
